<div>
    <a href="https://1ac.github.io">Index</a>   |||      <a href="https://1ac.github.io/rsschool-cv/">CV</a>
    <br />
</div>

<p>Разработка систем, удовлетворяющим нефункциональным требованям, — сложная тема. Межфункциональный характер многих нефункциональных требований затрудняет управление рисками, которые они привносят в проект. Это, в свою очередь, может привести к использованию двух нерациональных стратегий, парализующих разработку: недостаточное внимание к нефункциональным требованиям с самого начала проекта и другая крайность - неоправданно изощренная архитектура и чрезмерное усложнение приложения.</p>
<p>Производительность (<b>performance</b>) - оценка времени необходимой для обработки одной транзакции
</p>
<p>Пропускная способность (<b>throughput</b>) - количество транзакций которое система может обработать за определенное время. Пропускная способность всегда ограничена каким-либо узким местом в системе.
</p>
<p>Мощность (<b>capacity</b>) - максимальная пропускная способность, обеспечивающая при этом приемлемое время. Реакция на отдельные запросы
</p>
<h2>Основные нефункциональные требования </h2>
<ul>
    <li>Доступность</li>
    <li>Производительность</li>
    <li>Безопасность</li>
    <li>Сопровождение системы</li>
</ul>

<p>Нефункциональные требования имеют тенденцию влиять друг на друга неприятным образом. Например, повышение безопасности системы приводит к сложностям ее использования, гибка система часто менее производительная и тп. В реальности высокие показатели по одним параметрам достигаются за счет других. Методы выбора наиболее подходящей архитектуры путем анализа нефункциональных требований рассматриваются в книге *ATAM: Method for Architecture Evaluation^ Cernegie Mellon Software Engineering Institute 2000*.
</p>
<h1></h1> Анализ нефункциональных требований

<p>Имеет смысл определить ожидания заказчиков как истории, т.е. количественно, и задать их со степенью детализации, достаточной для анализа стоимости их преимуществ и расстановки приоритетов требований.
</p>
<p>При анализе нефункциональных требований важно выбрать оптимальный уровень детализации. Недостаточно сказать, что реакция должна быть "Как можно более быстрой". Такой критерий не устанавливает верхней планки для усилий команды и бюджета проекта.
</p>
<q> Если говорится, что время реакции не должно превышать двух секунд, означает ли это, что требование должно выполняться во всех ситуациях? </q>

<q>> Если один из зеркальных серверов потерпел крах, должна ли система и в этой ситуации обеспечить реакцию на протяжении не более двух секунд? </q>

<q> > Применяется ли этот попрог для редко выполнямых больших транзакций или только для наиболее распространенных? </q>

<q>  Две секунды это время завершения успешного акта взаимодействия пользователя с системой или время получения пользователем любой информации? </q>

<q>> Должно ли сообщение об ошибке уложится в две секунды, или это порог только для успешных? </q>

<q> > Должно ли требование выполнятся в пике нагрузке или только в нормальном режиме? </q>

**Необходимо фиксировать конкретные требования**

| Плохо    | Хорошо     |

|------------------|------------------|

| Система держит 5х| Cистема должна обрабатывать 3rps, 30 запросов в минуту, 300 запросов в час   |

<b>Особое внимание следует уделять: </b>

<ul>
    <li>Сетевое взаимодействие</li>
    <li>Запись на диск</li>
    <li>Стабильность приложения</li>
</ul>

<h3></h3>Программирование с учетом производительности**

<code> Мы должны забыть о небольшом повышении эффективности примерно в 97% случаев. Преждевременная оптимизация - это корень всех бед. </code>

<p>Он обязтельно проанализует критичный код, но только после того, как тот будет идентифицирован. </p>

<p>В современных системах наиболее дорогостоящие операции - сетевое взаимодействию через границы процессов и сетей, которое радикально ухудшает производительность и стабильность приложения. Такое взаимодействие следует минимизировать </p>

<p>Слишком ранняя или черезчур интенсивная оптимизация производительности приложения - неффективный и дорогостоящий подход, редко позволяющий получить высокопроизводительную систему. </p>

<h2> Стратегия решения проблем производительности </h2>
<ol>
    <li>Выбрать архитектуру приложения. Границы сетей, процессов и операций ввода вывода</li>
    <li>Шаблоны обеспечения стабильности и высокой производительности. [*Design and Deploy Production-Ready Sftware. The Progmatic Programmers*]</li>
    <li>Особенно осторожно относится к потока. Шаблоны заблокированных потоков наиболее частая причина сбоев.</li>
    <li>Автоматические тесты, подтверждающие требуемый уровень производительности.</li>
    <li>Использовать инструменты профилирования.</li>
    <li>При каждой возможности применяйте метрики производительности из реальной системы. Рабочая система ваш единственный источник реальных метрик. Особое внимание стоит уделять, количеству пользователей работающих паралейльно в системе. Шаблоны их поведения и объему рабочего набора данных.</li>
</ol>

<h2> Измерение производительности </h2>

<p><strong>Масштабирование</strong>. Изменение времени ответа на индивидуальный запрос и максимальное количество одновременных пользователей при добавлении дополнительных серверов </p>

<p><strong>Долговечность</strong>. Как долго может работать система без сбоев. </p>

<p><strong>Пропускная способность</strong>. Сколько транзакций, сообщений, щелчков на веб странице может обрабатывать. </p>

<p><strong>Нагрузка</strong>. Что произойдет с параметрами производительности при увеличении нагрузки. </p>

<p>Тестирование производительности на худшем оборудовании может не показать готовность приложения к рабочей среде, хотя и выявит серзные проблемы с производительностью. Это риск, который нужно просчитать для проекта, но не делайте наивных предположений в своих оценках.
</p>
<p>Не обманите себя, считая, что параметры приложения линейно зависят от параметров оборудования. Нельзя предполагать, что в рабочей среде приложения будет функционировать в два раза быстрее, если тактовая частота тестового процессора в два раза меньше, чем рабочего сервера.
</p>
<p>Выполните несколько масштабирующих запусков, чтобы исследовать различия в производительности между тестовой и рабочей средой.
</p>
## Требования для автоматических тестов производительности

- Тесты должны проверять систему реальной ситуации.

- Для теста необходимо установить пороговые значения, что бы он автоматический отправлял сообщения об успешности или неудачи.

- Продолжительность теста должна быть сравнительно не большой, необходимо определять результат на коротких выборках.

- Тест должен быть устойчивым к изменениям.

- Тест должен быть пригодным для агрегирования в более крупные сценарии для имитации реальных шаблонов эксплуатации приложения.

> Сначала идентифицируйте наиболее дорогостоящие транзакции, а затем удвойте или утройте их пропорцию в полном наборе транзакций.

<p>Обычно система тестирования производительности - ближайший аналог предполагаемой рабочей системы. В таком качестве она является ценным ресурсом. Тесты производительности создаются как ряд сущностей, структурированных на основе тестируемых ситуаций, то фактический получите изощренную имитацию рабочей системы.
</p>
**Тестирование ситуаций** - это имитация реального взаимодействия с системой. Организовав коллекции ситуаций, вы получаете возможность эффективно эксперементировать с инструментами диагностики в среде, близкой к рабочей.

- Воспроизведение сложных дефектов рабочей среды или приложения.
- Обнаружение и устранения утечек памяти.
- Тестирование долговечности.
- Оценка влияния сборки мусора.
- Настройка сборщиков мусора.
- Настройка конфигурационных параметров приложения.
- Имитация патологических, наихудших ситуаций.
- Сравнительная оценка решений сложных проблем.
- Имитация интеграционных сбоев.
- Измерение масштабируемости приложенияна основе ряда запусков с разными конфигурациями.
- Нагрузочное тестирование взаимодействия с внешними системами.
- Репетиция откатов сложных развертываний.
- Оценка отказоустойчивости служб.
- Выполнение эталонных тестов производительности